/*
 Generated by typeshare 1.7.0
*/

export type AbilityModifier = number;

export type AbilityScore = number;

export type ArmorClass = number;

export enum ClassType {
	Barbarian = "Barbarian",
	Bard = "Bard",
	Cleric = "Cleric",
	Druid = "Druid",
	Fighter = "Fighter",
	Monk = "Monk",
	Paladin = "Paladin",
	Ranger = "Ranger",
	Rogue = "Rogue",
	Sorcerer = "Sorcerer",
	Warlock = "Warlock",
	Wizard = "Wizard",
}

export enum HitDie {
	D6 = "D6",
	D8 = "D8",
	D10 = "D10",
	D12 = "D12",
}

export type HitDieByClassMap = Record<ClassType, HitDie>;

export type Level = number;

export type ProficiencyBonus = number;

export type ProficiencyType = 
	| { t: "weaponCategory", c: WeaponCategory }
	| { t: "weaponType", c: WeaponType }
	| { t: "armorCategory", c: ArmorCategory }
	| { t: "armorMaterial", c: Material };

export type ProficiencyTypeByClassMap = Record<ClassType, ProficiencyType[]>;

export interface AbilityScores {
	str: AbilityScore;
	dex: AbilityScore;
	con: AbilityScore;
	int: AbilityScore;
	wis: AbilityScore;
	cha: AbilityScore;
}

export interface Advantage {
}

export interface Disadvantage {
}

export enum ArmorType {
	Breastplate = "breastplate",
	ChainMail = "chainMail",
	ChainShirt = "chainShirt",
	HalfPlateArmor = "halfPlateArmor",
	HideArmor = "hideArmor",
	LeatherArmor = "leatherArmor",
	PaddedArmor = "paddedArmor",
	PlateArmor = "plateArmor",
	RingMail = "ringMail",
	ScaleMail = "scaleMail",
	Shield = "shield",
	SplintArmor = "splintArmor",
	StuddedLeatherArmor = "studdedLeatherArmor",
}

export enum ArmorCategory {
	Light = "Light",
	Medium = "Medium",
	Heavy = "Heavy",
	Shield = "Shield",
}

export enum Material {
	Metal = "metal",
	Unknown = "unknown",
}

export interface ArmorModel {
	armor_type: ArmorType;
	armor_class: ArmorClass;
	armor_category: ArmorCategory;
	primary_material: Material;
}

export interface CannotBeTargeted {
}

export interface HitDice {
	quantity: number;
	die: HitDie;
}

export enum WeaponType {
	Battleaxe = "battleaxe",
	Blowgun = "blowgun",
	Club = "club",
	CrossbowHand = "crossbowHand",
	CrossbowHeavy = "crossbowHeavy",
	CrossbowLight = "crossbowLight",
	Dagger = "dagger",
	Dart = "dart",
	Flail = "flail",
	Glaive = "glaive",
	Greataxe = "greataxe",
	Greatclub = "greatclub",
	Greatsword = "greatsword",
	Halberd = "halberd",
	Handaxe = "handaxe",
	Javelin = "javelin",
	Lance = "lance",
	LightHammer = "lightHammer",
	Longbow = "longbow",
	Longsword = "longsword",
	Mace = "mace",
	Maul = "maul",
	Morningstar = "morningstar",
	Pike = "pike",
	Quarterstaff = "quarterstaff",
	Rapier = "rapier",
	Scimitar = "scimitar",
	Shortbow = "shortbow",
	Shortsword = "shortsword",
	Sickle = "sickle",
	Sling = "sling",
	Spear = "spear",
	Trident = "trident",
	WarPick = "warPick",
	Warhammer = "warhammer",
	Whip = "whip",
}

export enum WeaponRange {
	Melee = "Melee",
	Ranged = "Ranged",
}

export enum WeaponCategory {
	Simple = "Simple",
	Martial = "Martial",
}

export enum DamageType {
	Acid = "Acid",
	Bludgeoning = "Bludgeoning",
	Cold = "Cold",
	Fire = "Fire",
	Force = "Force",
	Lightning = "Lightning",
	Necrotic = "Necrotic",
	Piercing = "Piercing",
	Poison = "Poison",
	Psychic = "Psychic",
	Radiant = "Radiant",
	Slashing = "Slashing",
	Thunder = "Thunder",
}

export enum DieType {
	D1 = "D1",
	D2 = "D2",
	D4 = "D4",
	D6 = "D6",
	D8 = "D8",
	D10 = "D10",
	D12 = "D12",
	D20 = "D20",
}

export enum DieLoading {
	Minimum = "Minimum",
	MinimumPlusOne = "MinimumPlusOne",
	AverageRoundedDown = "AverageRoundedDown",
	MaximumMinusOne = "MaximumMinusOne",
	Maximum = "Maximum",
}

export interface Die {
	die_type: DieType;
	die_loading?: DieLoading;
}

export interface Dice {
	quantity: number;
	die: Die;
}

export interface WeaponModel {
	weapon_type: WeaponType;
	weapon_range: WeaponRange;
	weapon_category: WeaponCategory;
	damage_type: DamageType;
	damage_dice: Dice;
}

export interface PhysicalAttackSummary {
	attackerProneContextBonus: string;
	defenderBonusFomCoverState: string;
	attackerWeaponProficiencyBonus: string;
	attackerArmorProficiencyPenalty: string;
	attackerWeaponAbilityModifier: string;
	attackerCombinedAdvantageType: string;
}

export interface PhysicalAttackOutcomeSummary {
	attack: string;
	attackRoll: string;
	targetAc: string;
	damageRoll?: string;
	hit: string;
	hpChange?: string;
}

export enum ProneState {
	/** No impact on attacker or defender advantage state */
	Upright = "Upright",
	/**
	 * Prone attackers have disadvantage
	 * 
	 * Attackers against prone targets have **advantage**
	 * if the target is within 5 feet
	 * 
	 * Attackers against prone targets have **disadvantage**
	 * if the target is greater than 5 feet away
	 */
	Prone = "Prone",
}

export enum CoverState {
	/** No impact on attacks or saving throws */
	None = "None",
	/** A target with half cover has a +2 bonus to AC and Dexterity saving throws. */
	Half = "Half",
	/** A target with three-quarters cover has a +5 bonus to AC and Dexterity saving throws. */
	ThreeQuarters = "ThreeQuarters",
	/** A target with total cover canâ€™t be targeted directly by an attack or a spell */
	Total = "Total",
}

export interface CharacterBuilder {
	name: string;
	level: number;
	hp: number;
	class: ClassType;
	abilityScores: AbilityScores;
	weaponType?: WeaponType;
	armorType?: ArmorType;
	proneState: ProneState;
	coverState: CoverState;
}

export interface Constants {
	MIN_LEVEL: number;
	MAX_LEVEL: number;
	MIN_ABILITY_SCORE: number;
	MAX_ABILITY_SCORE: number;
	DEFAULT_ABILITY_SCORE: number;
	DEFAULT_LEVEL: number;
	DEFAULT_CLASS_TYPE: ClassType;
	DEFAULT_PRONE_STATE: ProneState;
	DEFAULT_COVER_STATE: CoverState;
	WEAPON_PROFICIENCY_BONUS_TABLE: [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number];
	ABILITY_MODIFIER_TABLE: [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number];
	PROFICIENCY_TYPE_BY_CLASS_MAP: ProficiencyTypeByClassMap;
	HIT_DIE_BY_CLASS_MAP: HitDieByClassMap;
}

export type PhysicalAttackAttemptSummary = 
	| { t: "failure", c: string }
	| { t: "success", c: {
	after: PhysicalAttackOutcomeSummary;
}};

export interface PhysicalAttackAttemptSummaryWithPhrases {
	beforePhrase: string;
	summary: PhysicalAttackAttemptSummary;
	afterPhrase: string;
}

export interface CombatSummary {
	combatant1Summary?: PhysicalAttackSummary;
	combatant2Summary?: PhysicalAttackSummary;
	attacks: PhysicalAttackAttemptSummaryWithPhrases[];
	outcome: string;
}

export interface AttackRequest {
	attacker: CharacterBuilder;
	target: CharacterBuilder;
}

export enum AbilityType {
	/** Physical power */
	Strength = "Strength",
	/** Agility */
	Dexterity = "Dexterity",
	/** Endurance */
	Constitution = "Constitution",
	/** Reasoning and memory */
	Intelligence = "Intelligence",
	/** Perception and insight */
	Wisdom = "Wisdom",
	/** Personality */
	Charisma = "Charisma",
}

export type AdvantageType = 
	| { t: "advantage", c: Advantage }
	| { t: "normal", c?: undefined }
	| { t: "disadvantage", c: Disadvantage };

export type CoverBonus = 
	| { t: "canBeTargeted", c: CanBeTargetedCoverBonus }
	| { t: "cannotBeTargeted", c: CannotBeTargeted };

export type CanBeTargetedCoverBonus = 
	| { t: "none", c?: undefined }
	| { t: "armorClass", c: ArmorClass };

export enum DamageSource {
	Unarmed = "unarmed",
	Weapon = "weapon",
}

export type PhysicalAttackType = 
	| { t: "armed", c: WeaponModel }
	| { t: "unarmed", c?: undefined };

